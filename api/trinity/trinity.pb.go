// Code generated by protoc-gen-gogo.
// source: trinity.proto
// DO NOT EDIT!

/*
	Package trinity is a generated protocol buffer package.

	It is generated from these files:
		trinity.proto

	It has these top-level messages:
		RootConfig
		FIndexConfig
		IIndexConfig
		ConfigRequest
		SetResult
		FMValue
		ForwardMap
		DocStat
		IMValue
		InvertedMap
		FMapRequest
		IMapRequest
		StartSubsystemRequest
		StartSubsystemResponse
		SearchQuery
		SearchResponse
		SearchResult
*/
package trinity

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RootConfig struct {
	NodeRole string        `protobuf:"bytes,1,opt,name=NodeRole,proto3" json:"NodeRole,omitempty"`
	FIndex   *FIndexConfig `protobuf:"bytes,2,opt,name=FIndex" json:"FIndex,omitempty"`
	IIndex   *IIndexConfig `protobuf:"bytes,3,opt,name=IIndex" json:"IIndex,omitempty"`
	APIPort  string        `protobuf:"bytes,4,opt,name=APIPort,proto3" json:"APIPort,omitempty"`
}

func (m *RootConfig) Reset()                    { *m = RootConfig{} }
func (m *RootConfig) String() string            { return proto.CompactTextString(m) }
func (*RootConfig) ProtoMessage()               {}
func (*RootConfig) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{0} }

func (m *RootConfig) GetFIndex() *FIndexConfig {
	if m != nil {
		return m.FIndex
	}
	return nil
}

func (m *RootConfig) GetIIndex() *IIndexConfig {
	if m != nil {
		return m.IIndex
	}
	return nil
}

type FIndexConfig struct {
	MaxSize   uint32 `protobuf:"varint,1,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
	StorePath string `protobuf:"bytes,2,opt,name=store_path,json=storePath,proto3" json:"store_path,omitempty"`
}

func (m *FIndexConfig) Reset()                    { *m = FIndexConfig{} }
func (m *FIndexConfig) String() string            { return proto.CompactTextString(m) }
func (*FIndexConfig) ProtoMessage()               {}
func (*FIndexConfig) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{1} }

type IIndexConfig struct {
	MaxSize   uint32 `protobuf:"varint,1,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
	StorePath string `protobuf:"bytes,2,opt,name=store_path,json=storePath,proto3" json:"store_path,omitempty"`
}

func (m *IIndexConfig) Reset()                    { *m = IIndexConfig{} }
func (m *IIndexConfig) String() string            { return proto.CompactTextString(m) }
func (*IIndexConfig) ProtoMessage()               {}
func (*IIndexConfig) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{2} }

type ConfigRequest struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *ConfigRequest) Reset()                    { *m = ConfigRequest{} }
func (m *ConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfigRequest) ProtoMessage()               {}
func (*ConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{3} }

type SetResult struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *SetResult) Reset()                    { *m = SetResult{} }
func (m *SetResult) String() string            { return proto.CompactTextString(m) }
func (*SetResult) ProtoMessage()               {}
func (*SetResult) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{4} }

type FMValue struct {
	Locations []uint32 `protobuf:"varint,1,rep,name=locations" json:"locations,omitempty"`
}

func (m *FMValue) Reset()                    { *m = FMValue{} }
func (m *FMValue) String() string            { return proto.CompactTextString(m) }
func (*FMValue) ProtoMessage()               {}
func (*FMValue) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{5} }

type ForwardMap struct {
	FindexApiVersion uint32              `protobuf:"varint,1,opt,name=findex_api_version,json=findexApiVersion,proto3" json:"findex_api_version,omitempty"`
	Key              string              `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	TheMap           map[string]*FMValue `protobuf:"bytes,3,rep,name=the_map,json=theMap" json:"the_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ForwardMap) Reset()                    { *m = ForwardMap{} }
func (m *ForwardMap) String() string            { return proto.CompactTextString(m) }
func (*ForwardMap) ProtoMessage()               {}
func (*ForwardMap) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{6} }

func (m *ForwardMap) GetTheMap() map[string]*FMValue {
	if m != nil {
		return m.TheMap
	}
	return nil
}

type DocStat struct {
	Docname string `protobuf:"bytes,1,opt,name=docname,proto3" json:"docname,omitempty"`
	Count   uint32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *DocStat) Reset()                    { *m = DocStat{} }
func (m *DocStat) String() string            { return proto.CompactTextString(m) }
func (*DocStat) ProtoMessage()               {}
func (*DocStat) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{7} }

type IMValue struct {
	Docs []*DocStat `protobuf:"bytes,1,rep,name=docs" json:"docs,omitempty"`
}

func (m *IMValue) Reset()                    { *m = IMValue{} }
func (m *IMValue) String() string            { return proto.CompactTextString(m) }
func (*IMValue) ProtoMessage()               {}
func (*IMValue) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{8} }

func (m *IMValue) GetDocs() []*DocStat {
	if m != nil {
		return m.Docs
	}
	return nil
}

type InvertedMap struct {
	IindexApiVersion uint32              `protobuf:"varint,1,opt,name=iindex_api_version,json=iindexApiVersion,proto3" json:"iindex_api_version,omitempty"`
	Key              string              `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	TheMap           map[string]*IMValue `protobuf:"bytes,3,rep,name=the_map,json=theMap" json:"the_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *InvertedMap) Reset()                    { *m = InvertedMap{} }
func (m *InvertedMap) String() string            { return proto.CompactTextString(m) }
func (*InvertedMap) ProtoMessage()               {}
func (*InvertedMap) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{9} }

func (m *InvertedMap) GetTheMap() map[string]*IMValue {
	if m != nil {
		return m.TheMap
	}
	return nil
}

type FMapRequest struct {
	Dockey string `protobuf:"bytes,1,opt,name=dockey,proto3" json:"dockey,omitempty"`
}

func (m *FMapRequest) Reset()                    { *m = FMapRequest{} }
func (m *FMapRequest) String() string            { return proto.CompactTextString(m) }
func (*FMapRequest) ProtoMessage()               {}
func (*FMapRequest) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{10} }

type IMapRequest struct {
	Termkey string `protobuf:"bytes,1,opt,name=termkey,proto3" json:"termkey,omitempty"`
}

func (m *IMapRequest) Reset()                    { *m = IMapRequest{} }
func (m *IMapRequest) String() string            { return proto.CompactTextString(m) }
func (*IMapRequest) ProtoMessage()               {}
func (*IMapRequest) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{11} }

type StartSubsystemRequest struct {
	SubsystemName string `protobuf:"bytes,1,opt,name=subsystem_name,json=subsystemName,proto3" json:"subsystem_name,omitempty"`
}

func (m *StartSubsystemRequest) Reset()                    { *m = StartSubsystemRequest{} }
func (m *StartSubsystemRequest) String() string            { return proto.CompactTextString(m) }
func (*StartSubsystemRequest) ProtoMessage()               {}
func (*StartSubsystemRequest) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{12} }

type StartSubsystemResponse struct {
	ResponseCode string `protobuf:"bytes,1,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
}

func (m *StartSubsystemResponse) Reset()                    { *m = StartSubsystemResponse{} }
func (m *StartSubsystemResponse) String() string            { return proto.CompactTextString(m) }
func (*StartSubsystemResponse) ProtoMessage()               {}
func (*StartSubsystemResponse) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{13} }

type SearchQuery struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *SearchQuery) Reset()                    { *m = SearchQuery{} }
func (m *SearchQuery) String() string            { return proto.CompactTextString(m) }
func (*SearchQuery) ProtoMessage()               {}
func (*SearchQuery) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{14} }

type SearchResponse struct {
	Results []*SearchResult `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{15} }

func (m *SearchResponse) GetResults() []*SearchResult {
	if m != nil {
		return m.Results
	}
	return nil
}

type SearchResult struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Hash        string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *SearchResult) Reset()                    { *m = SearchResult{} }
func (m *SearchResult) String() string            { return proto.CompactTextString(m) }
func (*SearchResult) ProtoMessage()               {}
func (*SearchResult) Descriptor() ([]byte, []int) { return fileDescriptorTrinity, []int{16} }

func init() {
	proto.RegisterType((*RootConfig)(nil), "trinity.RootConfig")
	proto.RegisterType((*FIndexConfig)(nil), "trinity.FIndexConfig")
	proto.RegisterType((*IIndexConfig)(nil), "trinity.IIndexConfig")
	proto.RegisterType((*ConfigRequest)(nil), "trinity.ConfigRequest")
	proto.RegisterType((*SetResult)(nil), "trinity.SetResult")
	proto.RegisterType((*FMValue)(nil), "trinity.FMValue")
	proto.RegisterType((*ForwardMap)(nil), "trinity.ForwardMap")
	proto.RegisterType((*DocStat)(nil), "trinity.DocStat")
	proto.RegisterType((*IMValue)(nil), "trinity.IMValue")
	proto.RegisterType((*InvertedMap)(nil), "trinity.InvertedMap")
	proto.RegisterType((*FMapRequest)(nil), "trinity.FMapRequest")
	proto.RegisterType((*IMapRequest)(nil), "trinity.IMapRequest")
	proto.RegisterType((*StartSubsystemRequest)(nil), "trinity.StartSubsystemRequest")
	proto.RegisterType((*StartSubsystemResponse)(nil), "trinity.StartSubsystemResponse")
	proto.RegisterType((*SearchQuery)(nil), "trinity.SearchQuery")
	proto.RegisterType((*SearchResponse)(nil), "trinity.SearchResponse")
	proto.RegisterType((*SearchResult)(nil), "trinity.SearchResult")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for FIndex service

type FIndexClient interface {
	GetFMap(ctx context.Context, in *FMapRequest, opts ...grpc.CallOption) (*ForwardMap, error)
	SetFMap(ctx context.Context, in *ForwardMap, opts ...grpc.CallOption) (*SetResult, error)
}

type fIndexClient struct {
	cc *grpc.ClientConn
}

func NewFIndexClient(cc *grpc.ClientConn) FIndexClient {
	return &fIndexClient{cc}
}

func (c *fIndexClient) GetFMap(ctx context.Context, in *FMapRequest, opts ...grpc.CallOption) (*ForwardMap, error) {
	out := new(ForwardMap)
	err := grpc.Invoke(ctx, "/trinity.FIndex/GetFMap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fIndexClient) SetFMap(ctx context.Context, in *ForwardMap, opts ...grpc.CallOption) (*SetResult, error) {
	out := new(SetResult)
	err := grpc.Invoke(ctx, "/trinity.FIndex/SetFMap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FIndex service

type FIndexServer interface {
	GetFMap(context.Context, *FMapRequest) (*ForwardMap, error)
	SetFMap(context.Context, *ForwardMap) (*SetResult, error)
}

func RegisterFIndexServer(s *grpc.Server, srv FIndexServer) {
	s.RegisterService(&_FIndex_serviceDesc, srv)
}

func _FIndex_GetFMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FIndexServer).GetFMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trinity.FIndex/GetFMap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FIndexServer).GetFMap(ctx, req.(*FMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FIndex_SetFMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForwardMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FIndexServer).SetFMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trinity.FIndex/SetFMap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FIndexServer).SetFMap(ctx, req.(*ForwardMap))
	}
	return interceptor(ctx, in, info, handler)
}

var _FIndex_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trinity.FIndex",
	HandlerType: (*FIndexServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFMap",
			Handler:    _FIndex_GetFMap_Handler,
		},
		{
			MethodName: "SetFMap",
			Handler:    _FIndex_SetFMap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorTrinity,
}

// Client API for IIndex service

type IIndexClient interface {
	GetIMap(ctx context.Context, in *IMapRequest, opts ...grpc.CallOption) (*InvertedMap, error)
	SetIMap(ctx context.Context, in *InvertedMap, opts ...grpc.CallOption) (*SetResult, error)
}

type iIndexClient struct {
	cc *grpc.ClientConn
}

func NewIIndexClient(cc *grpc.ClientConn) IIndexClient {
	return &iIndexClient{cc}
}

func (c *iIndexClient) GetIMap(ctx context.Context, in *IMapRequest, opts ...grpc.CallOption) (*InvertedMap, error) {
	out := new(InvertedMap)
	err := grpc.Invoke(ctx, "/trinity.IIndex/GetIMap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iIndexClient) SetIMap(ctx context.Context, in *InvertedMap, opts ...grpc.CallOption) (*SetResult, error) {
	out := new(SetResult)
	err := grpc.Invoke(ctx, "/trinity.IIndex/SetIMap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for IIndex service

type IIndexServer interface {
	GetIMap(context.Context, *IMapRequest) (*InvertedMap, error)
	SetIMap(context.Context, *InvertedMap) (*SetResult, error)
}

func RegisterIIndexServer(s *grpc.Server, srv IIndexServer) {
	s.RegisterService(&_IIndex_serviceDesc, srv)
}

func _IIndex_GetIMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IIndexServer).GetIMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trinity.IIndex/GetIMap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IIndexServer).GetIMap(ctx, req.(*IMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IIndex_SetIMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvertedMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IIndexServer).SetIMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trinity.IIndex/SetIMap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IIndexServer).SetIMap(ctx, req.(*InvertedMap))
	}
	return interceptor(ctx, in, info, handler)
}

var _IIndex_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trinity.IIndex",
	HandlerType: (*IIndexServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIMap",
			Handler:    _IIndex_GetIMap_Handler,
		},
		{
			MethodName: "SetIMap",
			Handler:    _IIndex_SetIMap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorTrinity,
}

// Client API for Trinity service

type TrinityClient interface {
	GetRootConfig(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*RootConfig, error)
	SetRootConfig(ctx context.Context, in *RootConfig, opts ...grpc.CallOption) (*SetResult, error)
}

type trinityClient struct {
	cc *grpc.ClientConn
}

func NewTrinityClient(cc *grpc.ClientConn) TrinityClient {
	return &trinityClient{cc}
}

func (c *trinityClient) GetRootConfig(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*RootConfig, error) {
	out := new(RootConfig)
	err := grpc.Invoke(ctx, "/trinity.Trinity/GetRootConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trinityClient) SetRootConfig(ctx context.Context, in *RootConfig, opts ...grpc.CallOption) (*SetResult, error) {
	out := new(SetResult)
	err := grpc.Invoke(ctx, "/trinity.Trinity/SetRootConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Trinity service

type TrinityServer interface {
	GetRootConfig(context.Context, *ConfigRequest) (*RootConfig, error)
	SetRootConfig(context.Context, *RootConfig) (*SetResult, error)
}

func RegisterTrinityServer(s *grpc.Server, srv TrinityServer) {
	s.RegisterService(&_Trinity_serviceDesc, srv)
}

func _Trinity_GetRootConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrinityServer).GetRootConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trinity.Trinity/GetRootConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrinityServer).GetRootConfig(ctx, req.(*ConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trinity_SetRootConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RootConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrinityServer).SetRootConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trinity.Trinity/SetRootConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrinityServer).SetRootConfig(ctx, req.(*RootConfig))
	}
	return interceptor(ctx, in, info, handler)
}

var _Trinity_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trinity.Trinity",
	HandlerType: (*TrinityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRootConfig",
			Handler:    _Trinity_GetRootConfig_Handler,
		},
		{
			MethodName: "SetRootConfig",
			Handler:    _Trinity_SetRootConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorTrinity,
}

// Client API for Subsystem service

type SubsystemClient interface {
	StartMainLoop(ctx context.Context, in *StartSubsystemRequest, opts ...grpc.CallOption) (*StartSubsystemResponse, error)
}

type subsystemClient struct {
	cc *grpc.ClientConn
}

func NewSubsystemClient(cc *grpc.ClientConn) SubsystemClient {
	return &subsystemClient{cc}
}

func (c *subsystemClient) StartMainLoop(ctx context.Context, in *StartSubsystemRequest, opts ...grpc.CallOption) (*StartSubsystemResponse, error) {
	out := new(StartSubsystemResponse)
	err := grpc.Invoke(ctx, "/trinity.Subsystem/StartMainLoop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Subsystem service

type SubsystemServer interface {
	StartMainLoop(context.Context, *StartSubsystemRequest) (*StartSubsystemResponse, error)
}

func RegisterSubsystemServer(s *grpc.Server, srv SubsystemServer) {
	s.RegisterService(&_Subsystem_serviceDesc, srv)
}

func _Subsystem_StartMainLoop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartSubsystemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubsystemServer).StartMainLoop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trinity.Subsystem/StartMainLoop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubsystemServer).StartMainLoop(ctx, req.(*StartSubsystemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Subsystem_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trinity.Subsystem",
	HandlerType: (*SubsystemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartMainLoop",
			Handler:    _Subsystem_StartMainLoop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorTrinity,
}

// Client API for Gateway service

type GatewayClient interface {
	GetSearchQuery(ctx context.Context, in *SearchQuery, opts ...grpc.CallOption) (*SearchResponse, error)
}

type gatewayClient struct {
	cc *grpc.ClientConn
}

func NewGatewayClient(cc *grpc.ClientConn) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) GetSearchQuery(ctx context.Context, in *SearchQuery, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := grpc.Invoke(ctx, "/trinity.Gateway/GetSearchQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Gateway service

type GatewayServer interface {
	GetSearchQuery(context.Context, *SearchQuery) (*SearchResponse, error)
}

func RegisterGatewayServer(s *grpc.Server, srv GatewayServer) {
	s.RegisterService(&_Gateway_serviceDesc, srv)
}

func _Gateway_GetSearchQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).GetSearchQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trinity.Gateway/GetSearchQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).GetSearchQuery(ctx, req.(*SearchQuery))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trinity.Gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSearchQuery",
			Handler:    _Gateway_GetSearchQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorTrinity,
}

func (m *RootConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RootConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeRole) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.NodeRole)))
		i += copy(data[i:], m.NodeRole)
	}
	if m.FIndex != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTrinity(data, i, uint64(m.FIndex.Size()))
		n1, err := m.FIndex.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.IIndex != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTrinity(data, i, uint64(m.IIndex.Size()))
		n2, err := m.IIndex.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.APIPort) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.APIPort)))
		i += copy(data[i:], m.APIPort)
	}
	return i, nil
}

func (m *FIndexConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FIndexConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxSize != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintTrinity(data, i, uint64(m.MaxSize))
	}
	if len(m.StorePath) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.StorePath)))
		i += copy(data[i:], m.StorePath)
	}
	return i, nil
}

func (m *IIndexConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IIndexConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxSize != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintTrinity(data, i, uint64(m.MaxSize))
	}
	if len(m.StorePath) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.StorePath)))
		i += copy(data[i:], m.StorePath)
	}
	return i, nil
}

func (m *ConfigRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConfigRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	return i, nil
}

func (m *SetResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		data[i] = 0x8
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FMValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FMValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Locations) > 0 {
		for _, num := range m.Locations {
			data[i] = 0x8
			i++
			i = encodeVarintTrinity(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *ForwardMap) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ForwardMap) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FindexApiVersion != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintTrinity(data, i, uint64(m.FindexApiVersion))
	}
	if len(m.Key) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.TheMap) > 0 {
		for k, _ := range m.TheMap {
			data[i] = 0x1a
			i++
			v := m.TheMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTrinity(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTrinity(uint64(len(k))) + msgSize
			i = encodeVarintTrinity(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintTrinity(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintTrinity(data, i, uint64(v.Size()))
				n3, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *DocStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Docname) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Docname)))
		i += copy(data[i:], m.Docname)
	}
	if m.Count != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintTrinity(data, i, uint64(m.Count))
	}
	return i, nil
}

func (m *IMValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IMValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Docs) > 0 {
		for _, msg := range m.Docs {
			data[i] = 0xa
			i++
			i = encodeVarintTrinity(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InvertedMap) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InvertedMap) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IindexApiVersion != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintTrinity(data, i, uint64(m.IindexApiVersion))
	}
	if len(m.Key) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.TheMap) > 0 {
		for k, _ := range m.TheMap {
			data[i] = 0x1a
			i++
			v := m.TheMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTrinity(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTrinity(uint64(len(k))) + msgSize
			i = encodeVarintTrinity(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintTrinity(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintTrinity(data, i, uint64(v.Size()))
				n4, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	return i, nil
}

func (m *FMapRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FMapRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dockey) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Dockey)))
		i += copy(data[i:], m.Dockey)
	}
	return i, nil
}

func (m *IMapRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IMapRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Termkey) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Termkey)))
		i += copy(data[i:], m.Termkey)
	}
	return i, nil
}

func (m *StartSubsystemRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StartSubsystemRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubsystemName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.SubsystemName)))
		i += copy(data[i:], m.SubsystemName)
	}
	return i, nil
}

func (m *StartSubsystemResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StartSubsystemResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResponseCode) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.ResponseCode)))
		i += copy(data[i:], m.ResponseCode)
	}
	return i, nil
}

func (m *SearchQuery) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchQuery) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	return i, nil
}

func (m *SearchResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			data[i] = 0xa
			i++
			i = encodeVarintTrinity(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Title)))
		i += copy(data[i:], m.Title)
	}
	if len(m.Hash) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Hash)))
		i += copy(data[i:], m.Hash)
	}
	if len(m.Description) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintTrinity(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	return i, nil
}

func encodeFixed64Trinity(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Trinity(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTrinity(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *RootConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.NodeRole)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	if m.FIndex != nil {
		l = m.FIndex.Size()
		n += 1 + l + sovTrinity(uint64(l))
	}
	if m.IIndex != nil {
		l = m.IIndex.Size()
		n += 1 + l + sovTrinity(uint64(l))
	}
	l = len(m.APIPort)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func (m *FIndexConfig) Size() (n int) {
	var l int
	_ = l
	if m.MaxSize != 0 {
		n += 1 + sovTrinity(uint64(m.MaxSize))
	}
	l = len(m.StorePath)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func (m *IIndexConfig) Size() (n int) {
	var l int
	_ = l
	if m.MaxSize != 0 {
		n += 1 + sovTrinity(uint64(m.MaxSize))
	}
	l = len(m.StorePath)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func (m *ConfigRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func (m *SetResult) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *FMValue) Size() (n int) {
	var l int
	_ = l
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			n += 1 + sovTrinity(uint64(e))
		}
	}
	return n
}

func (m *ForwardMap) Size() (n int) {
	var l int
	_ = l
	if m.FindexApiVersion != 0 {
		n += 1 + sovTrinity(uint64(m.FindexApiVersion))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	if len(m.TheMap) > 0 {
		for k, v := range m.TheMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTrinity(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTrinity(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTrinity(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DocStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Docname)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovTrinity(uint64(m.Count))
	}
	return n
}

func (m *IMValue) Size() (n int) {
	var l int
	_ = l
	if len(m.Docs) > 0 {
		for _, e := range m.Docs {
			l = e.Size()
			n += 1 + l + sovTrinity(uint64(l))
		}
	}
	return n
}

func (m *InvertedMap) Size() (n int) {
	var l int
	_ = l
	if m.IindexApiVersion != 0 {
		n += 1 + sovTrinity(uint64(m.IindexApiVersion))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	if len(m.TheMap) > 0 {
		for k, v := range m.TheMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTrinity(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTrinity(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTrinity(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FMapRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Dockey)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func (m *IMapRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Termkey)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func (m *StartSubsystemRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubsystemName)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func (m *StartSubsystemResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResponseCode)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func (m *SearchQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovTrinity(uint64(l))
		}
	}
	return n
}

func (m *SearchResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTrinity(uint64(l))
	}
	return n
}

func sovTrinity(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTrinity(x uint64) (n int) {
	return sovTrinity(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RootConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RootConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RootConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeRole = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FIndex == nil {
				m.FIndex = &FIndexConfig{}
			}
			if err := m.FIndex.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IIndex == nil {
				m.IIndex = &IIndexConfig{}
			}
			if err := m.IIndex.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.APIPort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FIndexConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FIndexConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FIndexConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MaxSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorePath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IIndexConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IIndexConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IIndexConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MaxSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorePath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FMValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FMValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FMValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locations = append(m.Locations, v)
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardMap) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindexApiVersion", wireType)
			}
			m.FindexApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FindexApiVersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTrinity
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.TheMap == nil {
				m.TheMap = make(map[string]*FMValue)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTrinity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTrinity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthTrinity
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthTrinity
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &FMValue{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.TheMap[mapkey] = mapvalue
			} else {
				var mapvalue *FMValue
				m.TheMap[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Docname = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IMValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IMValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IMValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Docs = append(m.Docs, &DocStat{})
			if err := m.Docs[len(m.Docs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvertedMap) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvertedMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvertedMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IindexApiVersion", wireType)
			}
			m.IindexApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.IindexApiVersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTrinity
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.TheMap == nil {
				m.TheMap = make(map[string]*IMValue)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTrinity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTrinity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthTrinity
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthTrinity
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &IMValue{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.TheMap[mapkey] = mapvalue
			} else {
				var mapvalue *IMValue
				m.TheMap[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FMapRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FMapRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FMapRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dockey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dockey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IMapRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IMapRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IMapRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Termkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Termkey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartSubsystemRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartSubsystemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartSubsystemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsystemName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubsystemName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartSubsystemResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartSubsystemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartSubsystemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseCode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchQuery) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &SearchResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrinity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrinity(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrinity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTrinity(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTrinity
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrinity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTrinity
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTrinity
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTrinity(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTrinity = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTrinity   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("trinity.proto", fileDescriptorTrinity) }

var fileDescriptorTrinity = []byte{
	// 835 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0x23, 0xc7, 0xb4, 0x86, 0xa6, 0x61, 0x6c, 0x1d, 0x57, 0x15, 0x5a, 0x45, 0x58, 0xd7,
	0x8d, 0x0f, 0xad, 0x03, 0xa8, 0x7f, 0x49, 0x80, 0x06, 0x70, 0xd3, 0x5a, 0x25, 0x1a, 0x05, 0xee,
	0x32, 0xc8, 0xa1, 0x17, 0x62, 0x43, 0x6e, 0x2a, 0xa2, 0x12, 0x97, 0x59, 0x2e, 0x15, 0x29, 0xf7,
	0xbe, 0x43, 0x8f, 0x7d, 0x9c, 0x1e, 0x0b, 0x14, 0xbd, 0x17, 0xee, 0x8b, 0x14, 0xdc, 0xe5, 0x92,
	0x94, 0x22, 0x21, 0x97, 0xdc, 0x76, 0x66, 0xbf, 0xf9, 0x86, 0x33, 0xf3, 0xed, 0x10, 0x5c, 0x29,
	0xe2, 0x24, 0x96, 0xcb, 0xf3, 0x54, 0x70, 0xc9, 0x91, 0x5d, 0x9a, 0xf8, 0x0f, 0x0b, 0x80, 0x70,
	0x2e, 0x1f, 0xf1, 0xe4, 0x45, 0xfc, 0x0b, 0xea, 0xc1, 0xde, 0x13, 0x1e, 0x31, 0xc2, 0xa7, 0xac,
	0x6b, 0x0d, 0xac, 0xb3, 0x0e, 0xa9, 0x6c, 0xf4, 0x19, 0xec, 0x5e, 0x7a, 0x49, 0xc4, 0x16, 0xdd,
	0x1b, 0x03, 0xeb, 0xcc, 0x19, 0xde, 0x3a, 0x37, 0x9c, 0xda, 0xad, 0x29, 0x48, 0x09, 0x2a, 0xe0,
	0x9e, 0x86, 0xb7, 0xd7, 0xe0, 0xde, 0x0a, 0x5c, 0x5b, 0xa8, 0x0b, 0xf6, 0xc5, 0x95, 0x77, 0xc5,
	0x85, 0xec, 0xee, 0xa8, 0xc4, 0xc6, 0xc4, 0x3f, 0xc0, 0x7e, 0x33, 0x01, 0xfa, 0x00, 0xf6, 0x66,
	0x74, 0x11, 0x64, 0xf1, 0x6b, 0xfd, 0x8d, 0x2e, 0xb1, 0x67, 0x74, 0xe1, 0xc7, 0xaf, 0x19, 0xfa,
	0x08, 0x20, 0x93, 0x5c, 0xb0, 0x20, 0xa5, 0x72, 0xa2, 0x3e, 0xb3, 0x43, 0x3a, 0xca, 0x73, 0x45,
	0xe5, 0xa4, 0x60, 0xf2, 0xde, 0x0d, 0xd3, 0x09, 0xb8, 0xe5, 0xf7, 0xb3, 0x97, 0x39, 0xcb, 0x24,
	0x42, 0xb0, 0x23, 0x97, 0xa9, 0x69, 0x9a, 0x3a, 0xe3, 0x53, 0xe8, 0xf8, 0x4c, 0x12, 0x96, 0xe5,
	0x53, 0x59, 0xd4, 0x97, 0xe5, 0x61, 0xc8, 0xb2, 0x4c, 0x61, 0xf6, 0x88, 0x31, 0xf1, 0x1d, 0xb0,
	0x2f, 0xc7, 0xcf, 0xe8, 0x34, 0x67, 0xe8, 0x43, 0xe8, 0x4c, 0x79, 0x48, 0x65, 0xcc, 0x93, 0x02,
	0xd6, 0x3e, 0x73, 0x49, 0xed, 0xc0, 0x7f, 0x5b, 0x00, 0x97, 0x5c, 0xbc, 0xa2, 0x22, 0x1a, 0xd3,
	0x14, 0x7d, 0x0a, 0xe8, 0x45, 0x5c, 0x54, 0x13, 0xd0, 0x34, 0x0e, 0xe6, 0x4c, 0x64, 0x31, 0x4f,
	0xca, 0x3a, 0x0e, 0xf5, 0xcd, 0x45, 0x1a, 0x3f, 0xd3, 0x7e, 0x74, 0x08, 0xed, 0x5f, 0xd9, 0xb2,
	0xac, 0xa4, 0x38, 0xa2, 0x7b, 0x60, 0xcb, 0x09, 0x0b, 0x66, 0x34, 0xed, 0xb6, 0x07, 0xed, 0x33,
	0x67, 0x78, 0xbb, 0x1e, 0x68, 0x95, 0xe5, 0xfc, 0xe9, 0x84, 0x8d, 0x69, 0xfa, 0x7d, 0x22, 0xc5,
	0x92, 0xec, 0x4a, 0x65, 0xf4, 0x7e, 0x04, 0xa7, 0xe1, 0x36, 0xd4, 0x56, 0x4d, 0xfd, 0x09, 0xdc,
	0x9c, 0x17, 0x05, 0x95, 0x4a, 0x39, 0xac, 0x89, 0x75, 0xa1, 0x44, 0x5f, 0x3f, 0xb8, 0x71, 0xcf,
	0xc2, 0xf7, 0xc1, 0xfe, 0x8e, 0x87, 0xbe, 0xa4, 0xaa, 0x47, 0x11, 0x0f, 0x13, 0x3a, 0x33, 0x7d,
	0x34, 0x26, 0x3a, 0x82, 0x9b, 0x21, 0xcf, 0x13, 0xa9, 0x08, 0x5d, 0xa2, 0x0d, 0x7c, 0x17, 0x6c,
	0xaf, 0xec, 0xdc, 0xc7, 0xb0, 0x13, 0xf1, 0x50, 0x37, 0xad, 0x99, 0xb0, 0xa4, 0x26, 0xea, 0x16,
	0xff, 0x63, 0x81, 0xe3, 0x25, 0x73, 0x26, 0x24, 0x33, 0x2d, 0x8c, 0xb7, 0xb6, 0x30, 0x7e, 0x7b,
	0x0b, 0xef, 0xaf, 0xb7, 0x70, 0x50, 0x8b, 0xbc, 0x4e, 0xf3, 0x8e, 0x7b, 0xe8, 0xbd, 0xd9, 0xc3,
	0x53, 0x70, 0x2e, 0xc7, 0x34, 0x35, 0x62, 0x3c, 0x86, 0xdd, 0x88, 0x87, 0x35, 0x5f, 0x69, 0xe1,
	0x3b, 0xe0, 0x78, 0x0d, 0x58, 0x17, 0x6c, 0xc9, 0xc4, 0xac, 0xc6, 0x19, 0x13, 0x3f, 0x84, 0x5b,
	0xbe, 0xa4, 0x42, 0xfa, 0xf9, 0xf3, 0x6c, 0x99, 0x49, 0x36, 0x33, 0x21, 0xa7, 0x70, 0x90, 0x19,
	0x5f, 0xd0, 0x18, 0x94, 0x5b, 0x79, 0x9f, 0xd0, 0x19, 0xc3, 0xdf, 0xc0, 0xf1, 0x7a, 0x7c, 0x96,
	0xf2, 0x24, 0x63, 0xe8, 0x04, 0x5c, 0x51, 0x9e, 0x83, 0x90, 0x47, 0x26, 0x7e, 0xdf, 0x38, 0x1f,
	0xf1, 0x88, 0xe1, 0x13, 0x70, 0x7c, 0x46, 0x45, 0x38, 0xf9, 0x29, 0x67, 0x62, 0x59, 0x0c, 0xff,
	0x65, 0x71, 0x28, 0xb1, 0xda, 0xc0, 0x17, 0x70, 0xa0, 0x41, 0x15, 0xf7, 0x5d, 0xb0, 0x85, 0x7a,
	0x6c, 0x46, 0x06, 0xf5, 0xca, 0xa9, 0x90, 0xf9, 0x54, 0x12, 0x83, 0xc2, 0x3f, 0xc3, 0x7e, 0xf3,
	0xa2, 0x48, 0x24, 0x63, 0x59, 0xad, 0x3e, 0x6d, 0x14, 0x4f, 0x7b, 0x42, 0x33, 0xb3, 0x04, 0xd4,
	0x19, 0x0d, 0xc0, 0x89, 0x58, 0x16, 0x8a, 0x38, 0x2d, 0x9e, 0xa6, 0xda, 0x70, 0x1d, 0xd2, 0x74,
	0x0d, 0xe7, 0x66, 0x5b, 0xa2, 0xaf, 0xc0, 0x1e, 0x31, 0x59, 0xcc, 0x07, 0x1d, 0x35, 0x1e, 0x42,
	0x35, 0x87, 0xde, 0x7b, 0x1b, 0xde, 0x1d, 0x6e, 0xa1, 0x2f, 0xc0, 0xf6, 0xcb, 0xb8, 0x4d, 0x88,
	0x1e, 0x6a, 0x54, 0x57, 0x6e, 0x19, 0xdc, 0x1a, 0x2e, 0xcc, 0xda, 0x45, 0x5f, 0xab, 0xbc, 0xde,
	0x6a, 0xde, 0xc6, 0xfc, 0x7b, 0x47, 0x9b, 0xc4, 0x8a, 0x5b, 0xe8, 0x4b, 0x95, 0x78, 0x3d, 0xb0,
	0x86, 0x6c, 0xc9, 0xfc, 0x9b, 0x05, 0xf6, 0x53, 0xed, 0x47, 0x0f, 0xc1, 0x1d, 0x31, 0xd9, 0xf8,
	0xb1, 0x1c, 0x57, 0x21, 0x2b, 0x7b, 0xb3, 0x51, 0x7b, 0x0d, 0xc6, 0x2d, 0xf4, 0x00, 0x5c, 0x7f,
	0x25, 0x7e, 0x13, 0x6e, 0xcb, 0x77, 0x04, 0xd0, 0xa9, 0x74, 0x87, 0x08, 0xb8, 0x4a, 0x89, 0x63,
	0x1a, 0x27, 0x8f, 0x39, 0x4f, 0x51, 0xbf, 0x8e, 0xd9, 0xa4, 0xf0, 0xde, 0xed, 0xad, 0xf7, 0x5a,
	0x65, 0xb8, 0x35, 0x7c, 0x0c, 0xf6, 0x88, 0x4a, 0xf6, 0x8a, 0x2e, 0xd1, 0x05, 0x1c, 0x8c, 0x98,
	0x5c, 0x11, 0xeb, 0x9a, 0xe6, 0x94, 0xb7, 0xf7, 0xfe, 0x9b, 0x4a, 0x2c, 0xd9, 0xbe, 0x3d, 0xfc,
	0xf3, 0xba, 0x6f, 0xfd, 0x75, 0xdd, 0xb7, 0xfe, 0xbd, 0xee, 0x5b, 0xbf, 0xff, 0xd7, 0x6f, 0x3d,
	0xdf, 0x55, 0xff, 0xe8, 0xcf, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xe4, 0x16, 0x7d, 0x01, 0xb4,
	0x07, 0x00, 0x00,
}
